<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SkypeKit C++ Wrapper Reference: tutorial_16.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="islander3.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>tutorial_16.cpp</h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="Step16"></a>
C++ Tutorial Step 16: File transfers</h2>
<p>In this example, we will write a simple SkypeKit-based file transfer tool. The program works as auto-accepting file receiver (if launched without target skypename and filename command-line arguments. With two more arguments: valid skypename and filename, the program will transmit the file to target and exit.</p>
<p>File transfers are initiated through <a class="el" href="class_conversation.html#a9ce32165fa165dfcb2e7666d2fabc9d8">Conversation::PostFiles</a> method. This method does not directly return any <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> objects. Instead, we will need to monitor conversations for messages where <a class="el" href="class_message.html#a5012b8f0a3fcd1fec7bf3e6ba326ce23a747c40ef95a5a90497a69c8979181738">Message::P_TYPE</a> equals POSTED_FILES. From these <a class="el" href="class_message.html" title="Events in a conversation context are expressed as Messages. It is therefore useful to think of Messag...">Message</a> objects, we can then retrieve <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> objects, with <a class="el" href="class_message.html#a4bd1d77ee1f6961f710de21c2fe4ca8f">Message::GetTransfers</a>.</p>
<ul>
<li><a class="el" href="class_conversation.html#a887a117127a957342ae11338decb589b">Conversation::OnMessage</a> - for catching messages with P_TYPE == POSTED_FILES and retrieve <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> objects </li>
<li>Transfer::OnChange - for monitoring <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> object state and progress changes.</li>
</ul>
<p>Before we can proceed to file transfers, we will need to make some preparations.</p>
<p>Firstly, we will need to check all the incoming messages. For this we will need to keep a list of <a class="el" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a> references. Let's add this list to our <a class="el" href="class_skype.html" title="The main class that exposes Skype-related functionality to your application. Currently the SDK only s...">Skype</a> class and as soon as we are logged in - populate it with GetConversationList.</p>
<div class="fragment"><pre class="fragment">skype-&gt;GetConversationList(skype-&gt;allConvs);
fetch(skype-&gt;allConvs);
</pre></div><p>To keep this list up-to-date during program execution, we will also need to override <a class="el" href="class_skype.html#a6e47d0fc195995491b449336010bd520">Skype::OnConversationListChange</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MySkype::OnConversationListChange (
    <span class="keyword">const</span> <a name="_a0"></a><a class="code" href="class_conversation_ref.html" title="Reference to an Conversation class instance, equivalent to Conversation::Ref.">ConversationRef</a> &amp; conversation,
    <span class="keyword">const</span> <a class="code" href="class_conversation.html#a0eb196dd7006e1e37ba1c246c30d6183">Conversation::LIST_TYPE</a> &amp; type,
    <span class="keyword">const</span> <span class="keywordtype">bool</span> &amp; added)
{
    <span class="keywordflow">if</span> ((added) &amp;&amp; (type == MyConversation::ALL))
    {
        this-&gt;GetConversationList(this-&gt;allConvs);
        fetch(this-&gt;allConvs);
    };
};
</pre></div><p>Another category of objects that we need to monitor is in-progress <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> objects. As we cannot pre-fetch these objects as we did with Conversations, we will need to update this list in two places:</p>
<ul>
<li>MyConversation::OnMessage - if (Type == <a class="el" href="class_message.html#a5305592a3170872320962a09d8a1c7feaf7f96d9d7e5e68f2ec2e5afc64a3f197">Message::POSTED_FILES</a>), we will fetch the <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> objects from the message and add them to a global reference list. </li>
<li>in MyTransfer::OnChange - if the <a class="el" href="class_transfer.html#ae766d527cd974005da7114ff6c62d7a8afefbf42894ae1d23f1d3b909bae80273">Transfer::P_STATUS</a> gets set to a terminal value (CANCELLED, COMPLETED, FAILED, CANCELLED_BY_REMOTE) we can remove the <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> reference from our global list and it will get neatly garbage collected.</li>
</ul>
<p>Sending file</p>
<p>The code for sending file is in three places: </p>
<ul>
<li>Synchronous initiation of the transfer </li>
<li>Retrieval of the <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> object </li>
<li>Asynchronous monitoring for transfer progress.</li>
</ul>
<p>Firstly, in our initiation part will need to </p>
<ul>
<li>Retrieve a <a class="el" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a> object by remote <a class="el" href="class_participant.html" title="Conversation participant class. Instances of this class represent contacts when in the context of con...">Participant</a> skypename </li>
<li>Post the file in the <a class="el" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a> </li>
<li>Wait until the transfer gets done, cancelled, or ends up failing.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MySkype::sendFile (<a name="_a1"></a><a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> target, <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> fileName)
{
    <a name="_a2"></a><a class="code" href="class_s_e_string_list.html" title="SEStringList represents a list of strings (SEString objects).">SEStringList</a> targets;
    targets.<a name="a3"></a><a class="code" href="class_s_e_string_list.html#adfd5ca815c8569c0c3ee85486c2326e1">append</a>(target);

    MyConversation::Ref transferConv;

    GetConversationByParticipants(targets, transferConv, <span class="keyword">true</span>, <span class="keyword">true</span>);
    transferConv.fetch();

    <a name="_a4"></a><a class="code" href="class_s_e_filename_list.html" title="SEFilenameList Represents string list with file names in it.">SEFilenameList</a>          fileList;
    <a class="code" href="skype-embedded__2_8h.html#a818633607d7b34fe31a9c2903e1798ad">TRANSFER_SENDFILE_ERROR</a> errCode;
    <a name="_a5"></a><a class="code" href="class_s_e_filename.html" title="SEFilename Represents a file name. Currently not too much different from SEString.">SEFilename</a>              errFile;
    
    fileList.<a class="code" href="class_s_e_string_list.html#adfd5ca815c8569c0c3ee85486c2326e1">append</a>(fileName);

    <span class="keywordflow">if</span> ( transferConv-&gt;PostFiles(fileList, <span class="stringliteral">&quot;Sending file&quot;</span>, errCode, errFile) )
    {
        printf(<span class="stringliteral">&quot;Error: cannot create file transfer.\n&quot;</span>);
        isDoneSending = <span class="keyword">true</span>;
    };

    <span class="keywordflow">while</span> (!isDoneSending) {Delay(1);};
};
</pre></div><p>Retrieval of the <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> object goes into MyConversation::OnMessage, like this:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyConversation::OnMessage (<span class="keyword">const</span> <a name="_a6"></a><a class="code" href="class_message_ref.html" title="Reference to an Message class instance, equivalent to Message::Ref.">MessageRef</a> &amp;message)
{
    <span class="keywordtype">int</span> messageType = message-&gt;GetProp(<a name="a7"></a><a class="code" href="class_message.html#a5012b8f0a3fcd1fec7bf3e6ba326ce23a747c40ef95a5a90497a69c8979181738">Message::P_TYPE</a>).toInt();

    <span class="keywordflow">if</span> (messageType == <a name="a8"></a><a class="code" href="class_message.html#a5305592a3170872320962a09d8a1c7feaf7f96d9d7e5e68f2ec2e5afc64a3f197">Message::POSTED_FILES</a>)
    {
        MyTransfer::Refs transferList;
        message-&gt;GetTransfers(transferList);
        fetch(transferList);

        <span class="keywordflow">for</span> (uint i=0; i &lt; transferList.size(); i++)
        {
            globalTransferList-&gt;append(transferList[i]);
        };
    };
};
</pre></div><p>And now that we have references to <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> objects in globalTransferList, we can check for status updates: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyTransfer::OnChange(<span class="keywordtype">int</span> prop)
{
    <span class="keywordflow">if</span> (prop == <a name="a9"></a><a class="code" href="class_transfer.html#ae766d527cd974005da7114ff6c62d7a8afefbf42894ae1d23f1d3b909bae80273">Transfer::P_STATUS</a>)
    {
        <a class="code" href="class_transfer.html#ae904c64914e3e71877f2dd2221657460">Transfer::STATUS</a> transferStatus;
        GetPropStatus(transferStatus);

        <span class="keywordflow">if</span>  (   
                (transferStatus == CANCELLED) || 
                (transferStatus == COMPLETED) || 
                (transferStatus == FAILED) || 
                (transferStatus == CANCELLED_BY_REMOTE) 
            )
        {
            printf(<span class="stringliteral">&quot;Removing Transfer from Conversation transfers list\n&quot;</span>);
            <span class="keywordflow">if</span> ( globalTransferList-&gt;contains(this-&gt;ref()) )
            {
                globalTransferList-&gt;remove_val(this-&gt;ref());
            }

            <span class="keywordflow">if</span> (globalTransferList-&gt;size() == 0)
            {
                printf(<span class="stringliteral">&quot;All pending file transfers are complete.\nPress ENTER to quit.&quot;</span>);
                isDoneSending = <span class="keyword">true</span>;
            };
        };
    };
};
</pre></div><p>Upon reaching a terminal state, the global isDoneSending gets set and our MySkype::sendFile will drop back into main and the program will exit.</p>
<p>In addition to checking for terminal states, it would be nice to output some progress information, such as percentage of transfer completed and transfer speed. For this, let's add following at the end of MyTransfer::OnChange</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (prop == <a name="a10"></a><a class="code" href="class_transfer.html#ae766d527cd974005da7114ff6c62d7a8a2f9755e57452032db8184ee9299428f1">Transfer::P_BYTESTRANSFERRED</a>)
{
    <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> transferProgressStr;
    this-&gt;GetPropBytestransferred(transferProgressStr);
    uint transferProgress = transferProgressStr.<a name="a11"></a><a class="code" href="class_s_e_string.html#ad638d3479025452c9d3cc9a8df5bc41f">toUInt</a>();
    
    <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> fileSizeStr;
    this-&gt;GetPropFilesize(fileSizeStr);

    <span class="keywordtype">float</span> fileSize = fileSizeStr.<a class="code" href="class_s_e_string.html#ad638d3479025452c9d3cc9a8df5bc41f">toUInt</a>();
    <span class="keywordtype">float</span> progress = transferProgress / (fileSize / 100);   
    
    uint transferRate;
    this-&gt;GetPropBytespersecond(transferRate);
    <span class="keywordtype">float</span> transferRateInKb = transferRate / 1024;

    printf(<span class="stringliteral">&quot;Progress: %3.0f%% (%1.0f KB/s)\n&quot;</span>, progress, transferRateInKb);
};
</pre></div><p>The sending part is now complete. Let's see what needs to be done for incoming transfers.</p>
<p>As in case of incoming transfers, the entire process is entirely reactive - basically waiting for incoming POSTED_FILES messages, our "receiveFile" function ends up being somewhat ridiculous:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MySkype::receiveFile ()
{
    <span class="keywordtype">int</span> Ch;
    Ch = getchar();
};
</pre></div><p>The one additional thing that does need to be done for incoming transfers is calling <a class="el" href="class_transfer.html#ad9adc4a910d90130bbd699b3857fae2d">Transfer::Accept</a> for them.</p>
<p>The obvious way of doing this would be to simple monitor <a class="el" href="class_message.html#a5305592a3170872320962a09d8a1c7feaf7f96d9d7e5e68f2ec2e5afc64a3f197">Message::POSTED_FILES</a> type messages in our MyConversation::OnMessage callback and accept all incoming file transfers from there. Sadly, this does not work reliably. The reason for this is <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> status <a class="el" href="class_transfer.html#ae904c64914e3e71877f2dd2221657460a57038e51ac9d6f519664b2179af1a341">Transfer::PLACEHOLDER</a>. Normally, incoming transfer objects appear in OnMessage callback with status NEW. Such transfers can be accepted immediately. However, occasionally the transfer object is not yet fully prepared (PLACEHOLDER is indicator of that) and in such cases the <a class="el" href="class_transfer.html#ad9adc4a910d90130bbd699b3857fae2d">Transfer::Accept</a> would fail.</p>
<p>The next obvious thing would be to monitor for <a class="el" href="class_transfer.html#ae766d527cd974005da7114ff6c62d7a8afefbf42894ae1d23f1d3b909bae80273">Transfer::P_STATUS</a> changes in our transfer class OnChange callback and on P_STATUS of an incoming transfer becoming NEW - accept it there. Sadly, this does not work reliably either. The reason for that is that in normal cases, the P_STATUS of a <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> already is NEW by the time the object is created. Thus the status does not change anymore - and no property update happens. The PLACEHOLDER cases are exceptions.</p>
<p>The third obvious way is to check incoming transfers in both <a class="el" href="class_conversation.html#a887a117127a957342ae11338decb589b">Conversation::OnMessage</a> and Transfer::OnChange - most cases will be handled in OnMessage and the rest will get caught in Transfer::OnChange. This will work just fine.</p>
<p>As we are doing accepts from two places, it makes sense to have the necessary code piece as a separate method, like this:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyTransfer::AutoAccept()
{
  <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> fileName;
  <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> filePath;
  <span class="keywordtype">bool</span> success;
  this-&gt;GetPropFilename(fileName);
  printf(<span class="stringliteral">&quot;Auto-accepting incoming file transfer: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)fileName);
  this-&gt;Accept(fileName, success);

  <span class="keywordflow">if</span> (!success)
  {
    printf(<span class="stringliteral">&quot;Failed to accept incoming file transfer: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)fileName);
  };
};
</pre></div><p>The next thing is to handle the normal case - in MyConversation::OnMessage and check each <a class="el" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a> object for its P_TYPE. If the type is INCOMING, we can retrieve the (default) filename and call our AutoAccept. The MyConversation::OnMessage callback will end up looking like this:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyConversation::OnMessage (<span class="keyword">const</span> <a class="code" href="class_message_ref.html" title="Reference to an Message class instance, equivalent to Message::Ref.">MessageRef</a> &amp;message)
{
  <span class="keywordtype">int</span> messageType = message-&gt;GetProp(<a class="code" href="class_message.html#a5012b8f0a3fcd1fec7bf3e6ba326ce23a747c40ef95a5a90497a69c8979181738">Message::P_TYPE</a>).toInt();

  <span class="keywordflow">if</span> (messageType == <a class="code" href="class_message.html#a5305592a3170872320962a09d8a1c7feaf7f96d9d7e5e68f2ec2e5afc64a3f197">Message::POSTED_FILES</a>)
  {  
    MyTransfer::Refs transferList;
    message-&gt;GetTransfers(transferList);
    fetch(transferList);

    <span class="comment">// In case of incoming transfers, let&#39;s auto-accept them..</span>
    <a class="code" href="class_transfer.html#a2ace8eda846a4e395a4da87bb1fa5819">Transfer::TYPE</a> transferType;
    <a class="code" href="class_transfer.html#ae904c64914e3e71877f2dd2221657460">Transfer::STATUS</a> transferStatus;

    <span class="keywordflow">for</span> (uint i=0; i &lt; transferList.size(); i++)
    {
      globalTransferList-&gt;append(transferList[i]);

      transferList[i]-&gt;GetPropType(transferType);
      transferList[i]-&gt;GetPropStatus(transferStatus);
      <span class="keywordflow">if</span> ( (transferType == <a name="a12"></a><a class="code" href="class_transfer.html#a2ace8eda846a4e395a4da87bb1fa5819a08f2396c7a412a0987e4c86cd36648bb">Transfer::INCOMING</a>) &amp;&amp; (transferStatus == <a name="a13"></a><a class="code" href="class_transfer.html#ae904c64914e3e71877f2dd2221657460a569e4f43d7910f23e32e33f9cb4c585a">Transfer::NEW</a>) )
      {
        transferList[i]-&gt;AutoAccept();
      };
    };

    <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> bodyXml;
    message-&gt;GetPropBodyXml(bodyXml);
    printf(<span class="stringliteral">&quot;File transfer msg BodyXML:\n%s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)bodyXml);
  };
};
</pre></div><p>For the cases when the initial transferStatus was <a class="el" href="class_transfer.html#ae904c64914e3e71877f2dd2221657460a57038e51ac9d6f519664b2179af1a341">Transfer::PLACEHOLDER</a>, we will need to add the following piece to the MyTransfer::OnChange callback:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="class_transfer.html#ae904c64914e3e71877f2dd2221657460">Transfer::STATUS</a> transferStatus;
GetPropStatus(transferStatus);
<span class="keywordflow">if</span> (transferStatus == NEW)
{
  <a class="code" href="class_transfer.html#a2ace8eda846a4e395a4da87bb1fa5819">Transfer::TYPE</a> transferType;
  this-&gt;GetPropType(transferType);
  <span class="keywordflow">if</span> (transferType == <a class="code" href="class_transfer.html#a2ace8eda846a4e395a4da87bb1fa5819a08f2396c7a412a0987e4c86cd36648bb">Transfer::INCOMING</a>) this-&gt;AutoAccept();
};
</pre></div><h2><a class="anchor" id="Step16FullCode"></a>
Full code of this example</h2>
<div class="fragment"><pre class="fragment"><span class="comment">/****************************************************************************</span>
<span class="comment"></span>
<span class="comment">Getting Started With SkypeKit. Tutorial Application, Step 16.</span>
<span class="comment"></span>
<span class="comment">In this example, we will write a simple SkypeKit-based file transfer tool.</span>
<span class="comment">The program works as auto-accepting file receiver (if launched without target skypename</span>
<span class="comment">and filename command-line arguments. With two more arguments: valid skypename and filename,</span>
<span class="comment">the program will transmit the file to target and exit.</span>
<span class="comment"></span>
<span class="comment">**/</span>

<span class="preprocessor">#include &quot;<a class="code" href="skype-embedded__2_8h.html">skype-embedded_2.h</a>&quot;</span>
<span class="preprocessor">#include &quot;keypair.h&quot;</span>
<span class="preprocessor">#include &quot;tutorial_common.h&quot;</span>

<span class="keyword">using namespace </span>Sid;

<span class="keywordtype">bool</span> isDoneSending      = <span class="keyword">false</span>;

<span class="comment">// For us to keep getting Transfer object property updates</span>
<span class="comment">// we need to keep live references to these objects.</span>
<a name="_a14"></a><a class="code" href="class_transfer_refs.html" title="list of references to Transfer class instances, equivalent to Transfer::Refs">TransferRefs</a> * globalTransferList = <span class="keyword">new</span> <a class="code" href="class_transfer_refs.html" title="list of references to Transfer class instances, equivalent to Transfer::Refs">TransferRefs</a>();

<a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> myAccountName;
<a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> myAccountPsw;
<a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> targetName = <span class="stringliteral">&quot;&quot;</span>;   <span class="comment">// set from command line argument 3</span>
<a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> fileName  = <span class="stringliteral">&quot;&quot;</span>;    <span class="comment">// set from command line argument 4</span>

<span class="comment">//----------------------------------------------------------------------------</span>
<span class="comment">// Interface section</span>

<span class="keyword">class </span>MyTransfer : <span class="keyword">public</span> <a name="_a15"></a><a class="code" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a>
{
<span class="keyword">public</span>:
  <span class="keyword">typedef</span> DRef&lt;MyTransfer, Transfer&gt; Ref;
  <span class="keyword">typedef</span> DRefs&lt;MyTransfer, Transfer&gt; Refs;
  MyTransfer(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oid, SERootObject* root) : <a class="code" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a>(oid, root) {};

  <span class="keywordtype">void</span> AutoAccept();
  <span class="keywordtype">void</span> OnChange(<span class="keywordtype">int</span> prop);
};

<span class="keyword">class </span>MyConversation : <span class="keyword">public</span> <a name="_a16"></a><a class="code" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a>
{
<span class="keyword">public</span>:
  <span class="keyword">typedef</span> DRef&lt;MyConversation, Conversation&gt; Ref;
  <span class="keyword">typedef</span> DRefs&lt;MyConversation, Conversation&gt; Refs;

  MyConversation(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oid, SERootObject* root) : <a class="code" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a>(oid, root) {};
  <span class="keywordtype">void</span> OnMessage (<span class="keyword">const</span> <a class="code" href="class_message_ref.html" title="Reference to an Message class instance, equivalent to Message::Ref.">MessageRef</a> &amp;message);
};

<span class="keyword">class </span>MySkype : <span class="keyword">public</span> <a name="_a17"></a><a class="code" href="class_skype.html" title="The main class that exposes Skype-related functionality to your application. Currently the SDK only s...">Skype</a>
{
<span class="keyword">public</span>:
  MySkype() : <a class="code" href="class_skype.html" title="The main class that exposes Skype-related functionality to your application. Currently the SDK only s...">Skype</a>() {}

  <a name="_a18"></a><a class="code" href="class_account.html" title="Represents a local account. Encapsulates methods for Skype account creation, login and logout as well...">Account</a>*        newAccount(<span class="keywordtype">int</span> oid)       { <span class="keywordflow">return</span> <span class="keyword">new</span> MyAccount(oid, <span class="keyword">this</span>); }
  <a class="code" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a>*   newConversation(<span class="keywordtype">int</span> oid)  { <span class="keywordflow">return</span> <span class="keyword">new</span> MyConversation(oid, <span class="keyword">this</span>); }
  <a class="code" href="class_transfer.html" title="Transfer in this context refers to transferring (sending/receiving) files among Skype Contacts...">Transfer</a>*       newTransfer(<span class="keywordtype">int</span> oid)      { <span class="keywordflow">return</span> <span class="keyword">new</span> MyTransfer(oid, <span class="keyword">this</span>); }

  MyConversation::Refs allConvs;

  <span class="keywordtype">void</span> OnConversationListChange (
    <span class="keyword">const</span> <a class="code" href="class_conversation_ref.html" title="Reference to an Conversation class instance, equivalent to Conversation::Ref.">ConversationRef</a> &amp; conversation,
    <span class="keyword">const</span> <a class="code" href="class_conversation.html#a0eb196dd7006e1e37ba1c246c30d6183">Conversation::LIST_TYPE</a> &amp; type,
    <span class="keyword">const</span> <span class="keywordtype">bool</span> &amp; added);

  <span class="keywordtype">void</span> sendFile (<a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> target, <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> fileName);
  <span class="keywordtype">void</span> receiveFile ();
};

MySkype* skype;

<span class="comment">//----------------------------------------------------------------------------</span>
<span class="comment">// Implementation section</span>

<span class="keywordtype">void</span> MyTransfer::AutoAccept()
{
  <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> fileName;
  <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> filePath;
  <span class="keywordtype">bool</span> success;
  this-&gt;GetPropFilename(fileName);

  <span class="comment">// NB! Note that we do not specify file path here! As the actual work is done </span>
  <span class="comment">// in the runtime, by default all the incoming files will be placed in runtime&#39;s </span>
  <span class="comment">// local directory. Also, if you specify a relative path, the path will be </span>
  <span class="comment">// relative to the location of the runtime.</span>
  printf(<span class="stringliteral">&quot;Auto-accepting incoming file transfer: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)fileName);
  this-&gt;Accept(fileName, success);

  <span class="keywordflow">if</span> (!success)
  {
    printf(<span class="stringliteral">&quot;Failed to accept incoming file transfer: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)fileName);
  };
};

<span class="keywordtype">void</span> MyTransfer::OnChange(<span class="keywordtype">int</span> prop)
{
  <span class="comment">// Uncomment the following section to see ALL the Transfer class property changes</span><span class="comment"></span>
<span class="comment">  /**</span>
<span class="comment">  SEString value;</span>
<span class="comment">  value = this-&gt;GetProp(prop);</span>
<span class="comment">  SEStringList dbg = this-&gt;getPropDebug(prop, value);</span>
<span class="comment">  printf(&quot;%s %s -&gt; %s\n&quot;, (const char*)dbg[0], (const char*)dbg[1], (const char*)dbg[2]);</span>
<span class="comment">  **/</span>
  
  <span class="keywordflow">if</span> (prop == <a class="code" href="class_transfer.html#ae766d527cd974005da7114ff6c62d7a8afefbf42894ae1d23f1d3b909bae80273">Transfer::P_STATUS</a>)
  {
    <span class="comment">// Transfer::P_STATUS debug output..</span>
    <a class="code" href="class_transfer.html#ae904c64914e3e71877f2dd2221657460">Transfer::STATUS</a> transferStatus;
    GetPropStatus(transferStatus);
    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)tostring(transferStatus));

    <span class="comment">// Here we handle the case when an incoming FT was created with PLACEHOLDER status.</span>
    <span class="comment">// In that case we could not accept it immediately, and had to wait until the</span>
    <span class="comment">// status changed to NEW. Which is this place here.</span>
    <span class="keywordflow">if</span> (transferStatus == NEW)
    {
      <a class="code" href="class_transfer.html#a2ace8eda846a4e395a4da87bb1fa5819">Transfer::TYPE</a> transferType;
      this-&gt;GetPropType(transferType);
      <span class="keywordflow">if</span> (transferType == <a class="code" href="class_transfer.html#a2ace8eda846a4e395a4da87bb1fa5819a08f2396c7a412a0987e4c86cd36648bb">Transfer::INCOMING</a>) this-&gt;AutoAccept();
    };

    <span class="comment">// Is the transfer done yet?</span>
    <span class="keywordflow">if</span>  (  
        (transferStatus == CANCELLED) || 
        (transferStatus == COMPLETED) || 
        (transferStatus == FAILED) || 
        (transferStatus == CANCELLED_BY_REMOTE) 
        )
    {
      printf(<span class="stringliteral">&quot;Removing Transfer from Conversation transfers list\n&quot;</span>);
      <span class="keywordflow">if</span> ( globalTransferList-&gt;contains(this-&gt;ref()) )

      {
        globalTransferList-&gt;remove_val(this-&gt;ref());
      }

      <span class="keywordflow">if</span> (globalTransferList-&gt;size() == 0)
      {
        printf(<span class="stringliteral">&quot;All pending file transfers are complete.\nPress ENTER to quit.&quot;</span>);
        isDoneSending = <span class="keyword">true</span>;
      };
    };
  };
  
  <span class="comment">// Transfer progress output.</span>
  <span class="keywordflow">if</span> (prop == <a class="code" href="class_transfer.html#ae766d527cd974005da7114ff6c62d7a8a2f9755e57452032db8184ee9299428f1">Transfer::P_BYTESTRANSFERRED</a>)
  {
    <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> transferProgressStr;
    this-&gt;GetPropBytestransferred(transferProgressStr);
    uint transferProgress = transferProgressStr.<a class="code" href="class_s_e_string.html#ad638d3479025452c9d3cc9a8df5bc41f">toUInt</a>();
    
    <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> fileSizeStr;
    this-&gt;GetPropFilesize(fileSizeStr);
    
    <span class="comment">// fileSize is float here, to avoid trouble with </span>
    <span class="comment">// files lessthan 100 bytes in size.</span>
    <span class="keywordtype">float</span> fileSize = fileSizeStr.<a class="code" href="class_s_e_string.html#ad638d3479025452c9d3cc9a8df5bc41f">toUInt</a>();
    <span class="keywordtype">float</span> progress = transferProgress / (fileSize / 100);

    uint transferRate;
    this-&gt;GetPropBytespersecond(transferRate);
    <span class="keywordtype">float</span> transferRateInKb = transferRate / 1024;

    printf(<span class="stringliteral">&quot;Progress: %3.0f%% (%1.0f KB/s)\n&quot;</span>, progress, transferRateInKb);
  };
};

<span class="keywordtype">void</span> <a name="a19"></a><a class="code" href="class_conversation.html#a887a117127a957342ae11338decb589b">MyConversation::OnMessage</a> (<span class="keyword">const</span> <a class="code" href="class_message_ref.html" title="Reference to an Message class instance, equivalent to Message::Ref.">MessageRef</a> &amp;message)
{
  <span class="keywordtype">int</span> messageType = message-&gt;GetProp(<a class="code" href="class_message.html#a5012b8f0a3fcd1fec7bf3e6ba326ce23a747c40ef95a5a90497a69c8979181738">Message::P_TYPE</a>).toInt();

  <span class="keywordflow">if</span> (messageType == <a class="code" href="class_message.html#a5305592a3170872320962a09d8a1c7feaf7f96d9d7e5e68f2ec2e5afc64a3f197">Message::POSTED_FILES</a>)
  {  
    MyTransfer::Refs transferList;
    message-&gt;GetTransfers(transferList);
    fetch(transferList);

    <span class="comment">// In case of incoming transfers, let&#39;s auto-accept them..</span>
    <a class="code" href="class_transfer.html#a2ace8eda846a4e395a4da87bb1fa5819">Transfer::TYPE</a> transferType;
    <a class="code" href="class_transfer.html#ae904c64914e3e71877f2dd2221657460">Transfer::STATUS</a> transferStatus;

    <span class="keywordflow">for</span> (uint i=0; i &lt; transferList.size(); i++)
    {
      <span class="comment">// To keep getting MyTransfer class events, we need to store the references</span>
      globalTransferList-&gt;append(transferList[i]);

      <span class="comment">// For incomings, we need to check for transfer status, just to be sure.</span>
      <span class="comment">// In some cases, a transfer can appear with STATUS == PLACEHOLDER</span>
      <span class="comment">// As such transfers cannot be accepted, we will need to just store</span>
      <span class="comment">// the reference to Transfer Object and then check for further</span>
      <span class="comment">// status changes in Transfer::OnChange</span>
      transferList[i]-&gt;GetPropType(transferType);
      transferList[i]-&gt;GetPropStatus(transferStatus);
      <span class="keywordflow">if</span> ( (transferType == <a class="code" href="class_transfer.html#a2ace8eda846a4e395a4da87bb1fa5819a08f2396c7a412a0987e4c86cd36648bb">Transfer::INCOMING</a>) &amp;&amp; (transferStatus == <a class="code" href="class_transfer.html#ae904c64914e3e71877f2dd2221657460a569e4f43d7910f23e32e33f9cb4c585a">Transfer::NEW</a>) )
      {
        transferList[i]-&gt;AutoAccept();
      };
    };

    <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> bodyXml;
    message-&gt;GetPropBodyXml(bodyXml);
    printf(<span class="stringliteral">&quot;File transfer msg BodyXML:\n%s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)bodyXml);
  };
};


<span class="comment">// Keeping global conversation list up-to-date to </span>
<span class="comment">// make sure we get all the incoming nessages</span>

<span class="keywordtype">void</span> <a name="a20"></a><a class="code" href="class_skype.html#a6e47d0fc195995491b449336010bd520">MySkype::OnConversationListChange</a> (
  <span class="keyword">const</span> <a class="code" href="class_conversation_ref.html" title="Reference to an Conversation class instance, equivalent to Conversation::Ref.">ConversationRef</a> &amp; conversation,
  <span class="keyword">const</span> <a class="code" href="class_conversation.html#a0eb196dd7006e1e37ba1c246c30d6183">Conversation::LIST_TYPE</a> &amp; type,
  <span class="keyword">const</span> <span class="keywordtype">bool</span> &amp; added)
{
  <span class="keywordflow">if</span> ((added) &amp;&amp; (type == <a name="a21"></a><a class="code" href="class_conversation.html#a0eb196dd7006e1e37ba1c246c30d6183a63e387bb13cbc46e0724cbc568ed01aa">Conversation::ALL_CONVERSATIONS</a>))
  {
    this-&gt;GetConversationList(this-&gt;allConvs);
    fetch(this-&gt;allConvs);
  };
};


<span class="comment">// Nothing to do here, just waiting for incoming transfers</span>
<span class="comment">// Actual work is all in MyConversation::OnMessage</span>
<span class="keywordtype">void</span> MySkype::receiveFile ()
{
  getchar();
};


<span class="keywordtype">void</span> MySkype::sendFile (<a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> target, <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> fileName)
{
  <a class="code" href="class_s_e_string_list.html" title="SEStringList represents a list of strings (SEString objects).">SEStringList</a> targets;
  targets.<a class="code" href="class_s_e_string_list.html#adfd5ca815c8569c0c3ee85486c2326e1">append</a>(target);

  MyConversation::Ref transferConv;

  GetConversationByParticipants(targets, transferConv, <span class="keyword">true</span>, <span class="keyword">true</span>);
  transferConv.fetch();

  <a class="code" href="class_s_e_filename_list.html" title="SEFilenameList Represents string list with file names in it.">SEFilenameList</a> fileList;
  <a class="code" href="skype-embedded__2_8h.html#a818633607d7b34fe31a9c2903e1798ad">TRANSFER_SENDFILE_ERROR</a> errCode;
  <a class="code" href="class_s_e_filename.html" title="SEFilename Represents a file name. Currently not too much different from SEString.">SEFilename</a> errFile;
  
  fileList.<a class="code" href="class_s_e_string_list.html#adfd5ca815c8569c0c3ee85486c2326e1">append</a>(fileName);

  <span class="keywordflow">if</span> ( !transferConv-&gt;PostFiles(fileList, <span class="stringliteral">&quot;Sending file&quot;</span>, errCode, errFile) )
  {
    printf(<span class="stringliteral">&quot;Error: cannot create file transfer.\n&quot;</span>);
    isDoneSending = <span class="keyword">true</span>;
  };

  <span class="keywordflow">while</span> (!isDoneSending) { Delay(1); };
};


<span class="comment">//----------------------------------------------------------------------------</span>
<span class="comment">// Main</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
  printf(<span class="stringliteral">&quot;*****************************************************************\n&quot;</span>);
  printf(<span class="stringliteral">&quot; SkypeKit Tutorial, Step 16. - File Transfers.\n&quot;</span>);
  printf(<span class="stringliteral">&quot;*****************************************************************\n&quot;</span>);

  <span class="keywordflow">if</span> (argc &lt; 3)
  {
    printf(<span class="stringliteral">&quot;usage: tutorial_16 &lt;skypename&gt; &lt;password&gt; [target] [filename]\n&quot;</span>);
    <span class="keywordflow">return</span> 0;
  };

  myAccountName = argv[1];
  myAccountPsw  = argv[2];

  <span class="keywordflow">if</span> (argv[3])
  {
    targetName  = argv[3];
    <span class="keywordflow">if</span> (argv[4]) { fileName  = argv[4]; };
  };

  printf(<span class="stringliteral">&quot;Creating skype ..\n&quot;</span>);
  skype = <span class="keyword">new</span> MySkype();

  printf(<span class="stringliteral">&quot;Submitting application token..\n&quot;</span>);
  getKeyPair ();
  skype-&gt;init(keyBuf, inetAddr, portNum, <span class="stringliteral">&quot;streamlog.txt&quot;</span>);
  skype-&gt;start();

  printf(<span class="stringliteral">&quot;Retrieving account ..\n&quot;</span>);
  MyAccount::Ref account;

  <span class="keywordflow">if</span> (skype-&gt;GetAccount(myAccountName, account))
  {
    printf(<span class="stringliteral">&quot;Logging in..\n&quot;</span>);
    account-&gt;LoginWithPassword(myAccountPsw, <span class="keyword">false</span>, <span class="keyword">true</span>);
    account-&gt;BlockWhileLoggingIn();
    printf(<span class="stringliteral">&quot;Loggin complete.\n&quot;</span>);

    skype-&gt;GetConversationList(skype-&gt;allConvs);
    fetch(skype-&gt;allConvs);

    <span class="comment">// if we had 3rd and 4th cmd-line arguments - we go into send mode</span>
    <span class="keywordflow">if</span> ((targetName != <span class="stringliteral">&quot;&quot;</span>) &amp;&amp; (fileName != <span class="stringliteral">&quot;&quot;</span>))
    {
      printf(<span class="stringliteral">&quot;Sending %s to %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)fileName, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)targetName);
      skype-&gt;sendFile(targetName, fileName);
    }
    <span class="keywordflow">else</span> <span class="comment">// wait for incoming file transfers</span>
    {
      printf(<span class="stringliteral">&quot;Now accepting incoming file transfers..\n&quot;</span>);
      printf(<span class="stringliteral">&quot;Press ENTER to quit.\n&quot;</span>);
      skype-&gt;receiveFile();
    };
  
    printf(<span class="stringliteral">&quot;Logging out..\n&quot;</span>);
    account-&gt;Logout(<span class="keyword">false</span>);

    account-&gt;BlockWhileLoggingOut();
    printf(<span class="stringliteral">&quot;Logout complete.\n&quot;</span>);
  }
  <span class="keywordflow">else</span>
  {
      printf(<span class="stringliteral">&quot;Account does not exist\n&quot;</span>);
  };

  printf(<span class="stringliteral">&quot;Cleaning up.\n&quot;</span>);
  skype-&gt;stop();
  <span class="keyword">delete</span> skype;
  printf(<span class="stringliteral">&quot;Done.\n&quot;</span>);
  <span class="keywordflow">return</span> 0;
};
</pre></div> </div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<hr/>	
		<p><b>(c) Skype Technologies S.A. Confidential/Proprietary</b></p>		
		<p>Last updated: Fri Oct 7 2011</p>		
		</BODY>
</HTML>
