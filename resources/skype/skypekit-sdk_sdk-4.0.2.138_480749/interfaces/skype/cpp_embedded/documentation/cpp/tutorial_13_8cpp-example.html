<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SkypeKit C++ Wrapper Reference: tutorial_13.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="islander3.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>tutorial_13.cpp</h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="Step13"></a>
C++ Tutorial Step 13: Sending SMS messages</h2>
<p>In this example, we will write a simple SkypeKit-based SMS message sender.</p>
<p>To make things slightly more interesting, let's make the sender capable of taking multiple phone numbers as targets.</p>
<p>The first thing after login, would be to create an empty SMS object. This can be done with <a class="el" href="class_skype.html#a978a88ac603628ac5de02f24f96d5d30">Skype::CreateOutgoingSms</a> method, that reutrns us a valid <a class="el" href="class_sms_ref.html" title="Reference to an Sms class instance, equivalent to Sms::Ref.">SmsRef</a>.</p>
<div class="fragment"><pre class="fragment">MySms::Ref sms;
skype-&gt;CreateOutgoingSms(sms);
</pre></div><p>The next step is to set the message body text and target phone numbers (string list). </p>
<div class="fragment"><pre class="fragment"><a class="code" href="class_sms.html#ab7071a4cfe460dd063b0d780640355c4">Sms::SETBODYRESULT</a> setBodyResult;
uint freeUntilNextChunk;
<a name="_a0"></a><a class="code" href="class_s_e_string_list.html" title="SEStringList represents a list of strings (SEString objects).">SEStringList</a> chunks;
sms-&gt;SetBody(<span class="stringliteral">&quot;Test message&quot;</span>, setBodyResult, chunks, freeUntilNextChunk);
<span class="keywordtype">bool</span> targetsSuccess;
sms-&gt;SetTargets(targetList, targetsSuccess);
</pre></div><p>Note that the targetsSuccess return argument does not actually indicate that the targets were valid phone numbers. The <a class="el" href="class_sms.html#adbd9d276d815bf02a5f1a5e7071c59b7">Sms::SetTargets</a> method is asynchronous - it sets the target list and then drops out.</p>
<p>However, once the targets are set - actual target validity checking will take place in background. This will manifest itself as a series of <a class="el" href="class_sms.html#ae4583554f0d7e6dc4d8bb281e1ea5590af2d437ef4339f1e00e40cda8d3e747a8">Sms::P_TARGET_STATUSES</a> property change events (see MySms::OnChange).</p>
<p>Normal target status progression is: </p>
<ul>
<li>TARGET_ANALYZING </li>
<li>TARGET_ACCEPTABLE</li>
</ul>
<p>In case of failure (per target), progression is: </p>
<ul>
<li>TARGET_ANALYZING </li>
<li>TARGET_NOT_ROUTABLE</li>
</ul>
<p>Note that you do not quite know yet - what caused the TARGET_NOT_ROUTABLE state for the target. To get a better idea for what went wrong, you will need to actually send the SMS.</p>
<p>At this point you will have an <a class="el" href="class_sms.html" title="Wrapper class that includes SMS-specific properties and methods, such as P_BODY and GetTargetPrice...">Sms</a> object with body text and targets set, and in background, targets are being analyzed for their validity. There is also no knowledge of the price the user needs to pay for the message. The price property will only gets set once all targets have reached a determined state (TARGET_ACCEPTABLE or TARGET_NOT_ROUTABLE).</p>
<p>So, at this point, you have two choises:</p>
<p>1. You can wait until all targets reach either TARGET_ACCEPTABLE or TARGET_NOT_ROUTABLE, so that you can display the SMS price to the user before sending out the message.</p>
<p>2. You can send out the message immediately, in which case the target analyze process will still need to finish and then the message will be sent.</p>
<p>In our case, we will wait for sms-&gt;canSend to turn true, but if you wish to go for a simpler case, you can comment out the while (!sms-&gt;canSend) loop and the waiting for keypress, and the code will still work.</p>
<p>Now our <a class="el" href="class_sms.html" title="Wrapper class that includes SMS-specific properties and methods, such as P_BODY and GetTargetPrice...">Sms</a> object is ready for send. SMS send goes through <a class="el" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a> class - as with all other communications. In this case, through Conversation::PostSms method. </p>
<div class="fragment"><pre class="fragment"><a name="_a1"></a><a class="code" href="class_conversation_ref.html" title="Reference to an Conversation class instance, equivalent to Conversation::Ref.">ConversationRef</a> conv;
skype-&gt;GetConversationByParticipants(targetList, conv, <span class="keyword">true</span>, <span class="keyword">false</span>);
conv-&gt;PostSMS(sms, <span class="stringliteral">&quot;unused&quot;</span>);
</pre></div><p>For detecting success, we have <a class="el" href="class_sms.html#ae4583554f0d7e6dc4d8bb281e1ea5590a5c638152eb8d06e52e7daf123938bbf8">Sms::P_STATUS</a> states we can check: SENT_TO_SERVER - message has been sent to server and DELIVERED - we have confirmation of delivery. These status changes we can catch in Sms::OnChane and have two MySms class variables set accordingly (isSent and is Delivered).</p>
<p>Advantage of isSent is that it's much quicker and generally makes more sense in full-blown UI. In our case, as sending a single SMS is the entire purpose of the "UI", we might as well wait until sms-&gt;isDelivered.</p>
<p>In case of successful send, the state sequence should go like this: </p>
<div class="fragment"><pre class="fragment">SMS TIMESTAMP value: &lt;TIMESTAMP&gt;
SMS STATUS value: SENDING_TO_SERVER
SMS CHATMSG_ID value: &lt;MSG_ID&gt;
SMS TARGET &lt;TARGET&gt; STATUS = TARGET_DELIVERY_PENDING
SMS TARGET &lt;TARGET&gt; STATUS = TARGET_ACCEPTABLE
SMS TARGET &lt;TARGET&gt; STATUS = TARGET_DELIVERY_PENDING
SMS STATUS value: SENT_TO_SERVER
SMS TARGET &lt;TARGET&gt; STATUS = TARGET_DELIVERY_SUCCESSFUL
SMS STATUS value: DELIVERED                     
</pre></div><p>As this example is a command-line client, it makes sense to wait until we get back either success or failure notice.</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">while</span> ( (!sms-&gt;isDelivered) &amp;&amp; (!sms-&gt;hasFailed) ) { Delay(1); };
</pre></div><p>sms-&gt;hasFailed is being set when <a class="el" href="class_sms.html#ae4583554f0d7e6dc4d8bb281e1ea5590a5c638152eb8d06e52e7daf123938bbf8">Sms::P_STATUS</a> turns FAILED.</p>
<p>Now that the SMS is sent, there remains the matter of displaying it in your <a class="el" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a> UI. For this you can use the <a class="el" href="class_sms.html#ac79a6f2ec6036e40fdfbcdd5ae5e30cb">Sms::GetPropChatmsgId</a> method, that returns a <a class="el" href="class_message_ref.html" title="Reference to an Message class instance, equivalent to Message::Ref.">MessageRef</a> that references <a class="el" href="class_message.html" title="Events in a conversation context are expressed as Messages. It is therefore useful to think of Messag...">Message</a> object with Type POSTED_SMS. Once you have the <a class="el" href="class_message.html" title="Events in a conversation context are expressed as Messages. It is therefore useful to think of Messag...">Message</a> object, you can retrieve its BODY_XML text. The body text will contain not only original SMS body but also various other fields, between XML tags.</p>
<p>Example <a class="el" href="class_message.html" title="Events in a conversation context are expressed as Messages. It is therefore useful to think of Messag...">Message</a> body (with tabulation added): </p>
<div class="fragment"><pre class="fragment">&lt;sms alt=<span class="stringliteral">&quot;Test message&quot;</span>&gt;
    &lt;type&gt;2&lt;/type&gt;
    &lt;status&gt;6&lt;/status&gt;
    &lt;failurereason&gt;0&lt;/failurereason&gt;
    &lt;targets&gt;
        &lt;target status=<span class="stringliteral">&quot;6&quot;</span>&gt;+3725565678&lt;/target&gt;
    &lt;/targets&gt;
    &lt;price&gt;0.078 EUR&lt;/price&gt;
    &lt;body&gt;
        &lt;chunk <span class="keywordtype">id</span>=<span class="stringliteral">&quot;0&quot;</span>&gt;Test message&lt;/chunk&gt;
        &lt;untilnext&gt;148&lt;/untilnext&gt;
    &lt;/body&gt;
    &lt;sendtimestamp&gt;1298379016&lt;/sendtimestamp&gt;
&lt;/sms&gt;
</pre></div><h2><a class="anchor" id="Step13FullCode"></a>
Full code of this example</h2>
<div class="fragment"><pre class="fragment"><span class="comment">/****************************************************************************</span>
<span class="comment"></span>
<span class="comment">Getting Started With SkypeKit. Tutorial Application, Step 13.</span>
<span class="comment"></span>
<span class="comment">In this example, we will write a simple SkypeKit-based SMS message sender.</span>
<span class="comment"></span>
<span class="comment">To make things slightly more interesting, let&#39;s make the sender capable of</span>
<span class="comment">taking multiple phone numbers as targets.</span>
<span class="comment"></span>
<span class="comment">**/</span>

<span class="preprocessor">#include &lt;math.h&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="skype-embedded__2_8h.html">skype-embedded_2.h</a>&quot;</span>
<span class="preprocessor">#include &quot;keypair.h&quot;</span>
<span class="preprocessor">#include &quot;tutorial_common.h&quot;</span>

<span class="keyword">using namespace </span>Sid;

<a name="_a2"></a><a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a>      myAccountName;
<a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a>      myAccountPsw;
<a class="code" href="class_s_e_string_list.html" title="SEStringList represents a list of strings (SEString objects).">SEStringList</a>  targetList;

<span class="comment">//----------------------------------------------------------------------------</span>
<span class="comment">// Interface section</span>

<span class="keyword">class </span>MySms : <span class="keyword">public</span> <a name="_a3"></a><a class="code" href="class_sms.html" title="Wrapper class that includes SMS-specific properties and methods, such as P_BODY and GetTargetPrice...">Sms</a>
{
<span class="keyword">public</span>:
  <span class="keyword">typedef</span> DRef&lt;MySms, Sms&gt; Ref;
  <span class="keyword">typedef</span> DRefs&lt;MySms, Sms&gt; Refs;

  <span class="keywordtype">bool</span> canSend;       <span class="comment">// Set once all targets are either in TARGET_ACCEPTABLE or TARGET_NOT_ROUTABLE state</span>
  <span class="keywordtype">bool</span> isSent;        <span class="comment">// Set once Sms::P_STATUS goes to SENT_TO_SERVER</span>
  <span class="keywordtype">bool</span> hasFailed;     <span class="comment">// Set once Sms::P_STATUS goes to Sms::FAILED</span>
  <span class="keywordtype">bool</span> isDelivered;   <span class="comment">// Set once Sms::P_STATUS goes to Sms::DELIVERED</span>
  
  MySms(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oid, SERootObject* root) : <a class="code" href="class_sms.html" title="Wrapper class that includes SMS-specific properties and methods, such as P_BODY and GetTargetPrice...">Sms</a>(oid, root)
  {
    canSend     = <span class="keyword">false</span>;
    isSent      = <span class="keyword">false</span>;
    hasFailed   = <span class="keyword">false</span>;
    isDelivered = <span class="keyword">false</span>;
  };

  <span class="keywordtype">void</span> OnChange(<span class="keywordtype">int</span> prop);
  <span class="keywordtype">void</span> PrintFailureReason();
};

<span class="keyword">class </span>MySkype : <span class="keyword">public</span> <a name="_a4"></a><a class="code" href="class_skype.html" title="The main class that exposes Skype-related functionality to your application. Currently the SDK only s...">Skype</a>
{
<span class="keyword">public</span>:
  MySkype() : <a class="code" href="class_skype.html" title="The main class that exposes Skype-related functionality to your application. Currently the SDK only s...">Skype</a>() {};
  <a name="_a5"></a><a class="code" href="class_account.html" title="Represents a local account. Encapsulates methods for Skype account creation, login and logout as well...">Account</a>*    newAccount(<span class="keywordtype">int</span> oid) {<span class="keywordflow">return</span> <span class="keyword">new</span> MyAccount(oid, <span class="keyword">this</span>);}
  <a class="code" href="class_sms.html" title="Wrapper class that includes SMS-specific properties and methods, such as P_BODY and GetTargetPrice...">Sms</a>*        newSms(<span class="keywordtype">int</span> oid) {<span class="keywordflow">return</span> <span class="keyword">new</span> MySms(oid, <span class="keyword">this</span>);}
};

<span class="comment">//----------------------------------------------------------------------------</span>
<span class="comment">// Implementation section</span>

<span class="keywordtype">void</span> MySms::PrintFailureReason()
{
  <a class="code" href="class_sms.html#ab81f5ff2350cb0217000c4b18c0a97eb">Sms::FAILUREREASON</a> problem;
  this-&gt;GetPropFailurereason(problem);
  printf(<span class="stringliteral">&quot;%s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)tostring(problem));
};

<span class="keywordtype">void</span> MySms::OnChange(<span class="keywordtype">int</span> prop)
{
  <span class="comment">// As target statuses for all targets are kept in one Sms propery (P_TARGET_STATUSES),</span>
  <span class="comment">// we need to loop through all targets in the list separately.</span>

  <span class="keywordflow">if</span> (prop == <a name="a6"></a><a class="code" href="class_sms.html#ae4583554f0d7e6dc4d8bb281e1ea5590af2d437ef4339f1e00e40cda8d3e747a8">Sms::P_TARGET_STATUSES</a>)
  {
    <span class="keywordtype">bool</span> allTargetsAnalyzed = <span class="keyword">true</span>;

    <span class="keywordflow">for</span> (uint i=0; i &lt; targetList.size(); i++)
    {
      <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> targetNumber;
      targetNumber = targetList[i];

      <a class="code" href="class_sms.html#a1d169780756fc381b2a4575357daed71">Sms::TARGETSTATUS</a> targetStatus;
      this-&gt;GetTargetStatus(targetNumber, targetStatus);
      <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> statusAsText = tostring(targetStatus);

      printf(<span class="stringliteral">&quot;%s - %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)targetNumber, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)statusAsText);

      allTargetsAnalyzed = 
        allTargetsAnalyzed 
        &amp;&amp; ((targetStatus == Sms::TARGET_NOT_ROUTABLE) || (targetStatus == <a name="a7"></a><a class="code" href="class_sms.html#a1d169780756fc381b2a4575357daed71aa646997b610a0d1dc0df7ecd94aaf16e">Sms::TARGET_ACCEPTABLE</a>));

      <span class="keywordflow">if</span> (targetStatus == <a name="a8"></a><a class="code" href="class_sms.html#a1d169780756fc381b2a4575357daed71ab6938e55ce34396d1f9b5eff415668cb">Sms::TARGET_NOT_ROUTABLE</a>)
      {<span class="comment"></span>
<span class="comment">        /** At this point, we already know that the SMS delivery will fail - because the target</span>
<span class="comment">        status was TARGET_NOT_ROUTABLE, so it looks like there is no reason to even attempt</span>
<span class="comment">        sending it. However, at this point we still don&#39;t know what was the reason behind</span>
<span class="comment">        &quot;no routabilty&quot; - The Sms FAILURE_REASON property will only get set during attempt</span>
<span class="comment">        to send it.</span>
<span class="comment"></span>
<span class="comment">        One common cause of failure would be an attempt to send SMS messages from account with</span>
<span class="comment">        zero balance. That too would trigger TARGET_NOT_ROUTABLE. But your UI would not know</span>
<span class="comment">        this - as while in composing state, the SMS failure reason will remain empty.</span>
<span class="comment"></span>
<span class="comment">        Thus, it actually makes sense -not- to stop the sending attempt here, post the SMS,</span>
<span class="comment">        knowing that it will fail, and then retrieve the actual error cause. **/</span>

        printf(<span class="stringliteral">&quot;WARNING: unroutable target %s!\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)targetNumber);
      };
    };
    this-&gt;canSend = allTargetsAnalyzed;
    <span class="keywordflow">return</span>;
  };
<span class="comment"></span>
<span class="comment">  /** The price property as well, is common to all targets (targets may have different prices).</span>
<span class="comment">  The total price we can look at via Sms::GetPropPrice but to get to target specific prices</span>
<span class="comment">  we will need to loop through targets and use Sms::GetTargetPrice **/</span>
  <span class="keywordflow">if</span>   (prop == <a name="a9"></a><a class="code" href="class_sms.html#ae4583554f0d7e6dc4d8bb281e1ea5590acb96491b3f7432027b3e7884d2e7cce2">Sms::P_PRICE</a>)
  {
    <span class="keywordflow">for</span> (uint i=0; i &lt; targetList.size(); i++)
    {
<span class="comment"></span>
<span class="comment">      /** The price information is kept in three properties:</span>
<span class="comment">      1. price - integer, i.e. 123</span>
<span class="comment">      2. precision - integer, i.e. 3</span>
<span class="comment">      3. currency - string - i.e. &quot;EUR&quot;</span>
<span class="comment"></span>
<span class="comment">      To calculate actual price value: price / 10^precision</span>
<span class="comment">      I.e. 123 / 10^3 = 0.123 EUR</span>
<span class="comment"></span>
<span class="comment">      Note that the price value for any given target (and the total</span>
<span class="comment">      price of the SMS) will only become available once the target</span>
<span class="comment">      has reached TARGET_ACCEPTABLE status. Until then the price</span>
<span class="comment">      will remain at its default value: -1 **/</span>

      <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> targetNumber;
      targetNumber = targetList[i];

      <span class="comment">// Getting target price</span>
      uint price;
      this-&gt;GetTargetPrice(targetNumber, price);

      <span class="keywordflow">if</span> (price == MAX_UINT)
      {
        printf(<span class="stringliteral">&quot;SMS price for %s is still unknown!\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)targetNumber);
        <span class="keywordflow">return</span>;
      };

      uint precision;
      this-&gt;GetPropPricePrecision(precision);
      <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> currency;
      this-&gt;GetPropPriceCurrency(currency);

      <span class="keywordtype">float</span> f = precision;
      <span class="keywordtype">float</span> actualPrice = price / pow(10, f);

      printf(<span class="stringliteral">&quot;SMS Price for %s is set to %2.3f %s\n&quot;</span>, 
        (<span class="keyword">const</span> <span class="keywordtype">char</span>*)targetNumber, 
        actualPrice, 
        (<span class="keyword">const</span> <span class="keywordtype">char</span>*)currency);

      <span class="comment">// Getting SMS total price (we can reuse currency and precision)</span>
      this-&gt;GetPropPrice(price);
      actualPrice = price / pow(10, f);
      printf(<span class="stringliteral">&quot;Total SMS price is now %2.3f %s\n&quot;</span>, 
        actualPrice, 
        (<span class="keyword">const</span> <span class="keywordtype">char</span>*)currency);
    };
    <span class="keywordflow">return</span>;
  };

  <span class="keywordflow">if</span> (prop == <a name="a10"></a><a class="code" href="class_sms.html#ae4583554f0d7e6dc4d8bb281e1ea5590a5c638152eb8d06e52e7daf123938bbf8">Sms::P_STATUS</a>)
  {
    <a class="code" href="class_sms.html#ae47f8924987a734e6680e7d9341917ba">Sms::STATUS</a> status;
    this-&gt;GetPropStatus(status);
    this-&gt;isSent        = (status == Sms::SENT_TO_SERVER);
    this-&gt;hasFailed     = (status == Sms::FAILED);
    this-&gt;isDelivered   = (status == Sms::DELIVERED);
  };

  <span class="comment">// Logging class / property / new value</span>
  <a class="code" href="class_s_e_string_list.html" title="SEStringList represents a list of strings (SEString objects).">SEStringList</a> dbg;
  <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> someProp;
  someProp = this-&gt;GetProp(prop);
  dbg = this-&gt;getPropDebug(prop, someProp);
  printf(<span class="stringliteral">&quot;%s %s value: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)dbg[0], (<span class="keyword">const</span> <span class="keywordtype">char</span>*)dbg[1], (<span class="keyword">const</span> <span class="keywordtype">char</span>*)dbg[2]);
};


<span class="comment">//----------------------------------------------------------------------------</span>
<span class="comment">// Main</span>

MySkype* skype = 0;

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
  printf(<span class="stringliteral">&quot;*****************************************************************\n&quot;</span>);
  printf(<span class="stringliteral">&quot; SkypeKit Tutorial, Step 13. - Sending SMS messages.\n&quot;</span>);
  printf(<span class="stringliteral">&quot;*****************************************************************\n&quot;</span>);

  <span class="keywordflow">if</span> (argc &lt; 4)
  {
    printf(<span class="stringliteral">&quot;usage: tutorial_13 &lt;skypename&gt; &lt;password&gt; &lt;target&gt; [target2]\n&quot;</span>);
    <span class="keywordflow">return</span> 0;
  };

  myAccountName = argv[1];
  myAccountPsw = argv[2];

  targetList.append(argv[3]);

  <span class="comment">// Second SMS target is optional.</span>
  <span class="keywordflow">if</span> (argv[4])
  {
    targetList.append(argv[4]);
  };

  printf(<span class="stringliteral">&quot;Creating skype ..\n&quot;</span>);
  skype = <span class="keyword">new</span> MySkype();
  printf(<span class="stringliteral">&quot;Submitting application token..\n&quot;</span>);
  getKeyPair ();
  skype-&gt;init(keyBuf, inetAddr, portNum, <span class="stringliteral">&quot;streamlog.txt&quot;</span>);
  skype-&gt;start();

  printf(<span class="stringliteral">&quot;Retrieving account ..\n&quot;</span>);
  MyAccount::Ref account;

  <span class="keywordflow">if</span> (skype-&gt;GetAccount(myAccountName, account))
  {
    printf(<span class="stringliteral">&quot;Logging in..\n&quot;</span>);
    account-&gt;LoginWithPassword(myAccountPsw, <span class="keyword">false</span>, <span class="keyword">true</span>);
    account-&gt;BlockWhileLoggingIn();
    printf(<span class="stringliteral">&quot;Loggin complete.\n&quot;</span>);

    printf(<span class="stringliteral">&quot;Press ENTER to compose SMS\n&quot;</span>);
    getchar();

    <span class="comment">// SMS objects are created with Skype::CreateOutgoingSms method.</span>
    MySms::Ref sms;
    skype-&gt;CreateOutgoingSms(sms);

    <span class="comment">// Sms::SetBody will attempt to set the message body text.</span>
    <a class="code" href="class_sms.html#ab7071a4cfe460dd063b0d780640355c4">Sms::SETBODYRESULT</a> setBodyResult;
    uint freeUntilNextChunk;
    <a class="code" href="class_s_e_string_list.html" title="SEStringList represents a list of strings (SEString objects).">SEStringList</a> chunks;
    sms-&gt;SetBody(<span class="stringliteral">&quot;Test message&quot;</span>, setBodyResult, chunks, freeUntilNextChunk);

    <span class="keywordflow">if</span> (setBodyResult != <a name="a11"></a><a class="code" href="class_sms.html#ab7071a4cfe460dd063b0d780640355c4a6ee94c640e2c749a443725d5a47a63ef">Sms::BODY_OK</a>)
    {
      printf(<span class="stringliteral">&quot;Failed to set SMS body property.\n&quot;</span>);
    }
    <span class="keywordflow">else</span>
    {
      printf(<span class="stringliteral">&quot;Number of SMS chunks used: %d, free characters until next chunk: %d\n&quot;</span>, chunks.<a name="a12"></a><a class="code" href="class_s_e_string_list.html#a0f86fa4676e6bea28f9923955a503360">size</a>(), freeUntilNextChunk);

      <span class="keywordtype">bool</span> targetsSuccess;
      sms-&gt;SetTargets(targetList, targetsSuccess);
      <span class="keywordflow">if</span> (!targetsSuccess)
      {
        printf(<span class="stringliteral">&quot;Failed to set SMS targets.\n&quot;</span>);
      }
      <span class="keywordflow">else</span>
      {
        <span class="comment">// canSend gets set from MySms::OnChange</span>
        <span class="keywordflow">while</span> (!sms-&gt;canSend) { Delay(1); };

        printf(<span class="stringliteral">&quot;Press ENTER to send SMS\n&quot;</span>);
        getchar();

        <span class="comment">// While created in global scope, posting Sms objects goes through</span>
        <span class="comment">// conversations.</span>

        <a class="code" href="class_conversation_ref.html" title="Reference to an Conversation class instance, equivalent to Conversation::Ref.">ConversationRef</a> conv;
        skype-&gt;GetConversationByParticipants(targetList, conv, <span class="keyword">true</span>, <span class="keyword">false</span>);

        <span class="comment">// The body argument in PostSMS is currently unused.</span>
        conv-&gt;PostSMS(sms, <span class="stringliteral">&quot;unused&quot;</span>);
<span class="comment"></span>
<span class="comment">        /** For detecting success, we have two variables we can check:</span>
<span class="comment">        sms-&gt;isSent - message has been sent to server</span>
<span class="comment">        sms-&gt;isDelivered - we have confirmation of delivery. **/</span>

        <span class="keywordflow">while</span> ( (!sms-&gt;isDelivered) &amp;&amp; (!sms-&gt;hasFailed) ) { Delay(1); };
        <span class="keywordflow">if</span> (sms-&gt;hasFailed) { sms-&gt;PrintFailureReason(); };

        <span class="comment">// Printing out corresponding Message object body text</span>
        <a name="_a13"></a><a class="code" href="class_message_ref.html" title="Reference to an Message class instance, equivalent to Message::Ref.">MessageRef</a> msg;
        sms-&gt;GetPropChatmsgId(msg);

        <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> msgBody;
        msg-&gt;GetPropBodyXml(msgBody);

        printf(<span class="stringliteral">&quot;\nCorresponding Message object body text:\n%s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)msgBody);
      };
    };

    printf(<span class="stringliteral">&quot;Press ENTER to quit.\n&quot;</span>);
    getchar();
<span class="comment"></span>
<span class="comment">    /** Printing out remaining account balance. The logic here is the same</span>
<span class="comment">    as in case of Sms::P_PRICE, in MySms::OnChange **/</span>
    uint balance, precision;
    <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> currency;
    account-&gt;GetPropSkypeoutBalance(balance);
    account-&gt;GetPropSkypeoutBalanceCurrency(currency);
    account-&gt;GetPropSkypeoutPrecision(precision);
    <span class="keywordtype">float</span> f = precision;
    <span class="keywordtype">float</span> actualBalance = balance / pow(10, f);
    printf(<span class="stringliteral">&quot;Remaining balance on this account: %2.3f %s\n&quot;</span>, actualBalance, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)currency);

    printf(<span class="stringliteral">&quot;Logging out..\n&quot;</span>);
    account-&gt;Logout(<span class="keyword">false</span>);
    account-&gt;BlockWhileLoggingOut();
    printf(<span class="stringliteral">&quot;Logout complete.\n&quot;</span>);
  }
  <span class="keywordflow">else</span>
  {
      printf(<span class="stringliteral">&quot;Account does not exist\n&quot;</span>);
  };

  printf(<span class="stringliteral">&quot;Cleaning up.\n&quot;</span>);
  skype-&gt;stop();
  <span class="keyword">delete</span> skype;
  printf(<span class="stringliteral">&quot;Done.\n&quot;</span>);
  <span class="keywordflow">return</span> 0;
};
</pre></div> </div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<hr/>	
		<p><b>(c) Skype Technologies S.A. Confidential/Proprietary</b></p>		
		<p>Last updated: Fri Oct 7 2011</p>		
		</BODY>
</HTML>
