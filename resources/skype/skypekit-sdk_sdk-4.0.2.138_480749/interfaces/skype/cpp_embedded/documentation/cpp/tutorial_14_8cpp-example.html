<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SkypeKit C++ Wrapper Reference: tutorial_14.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="islander3.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>tutorial_14.cpp</h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="Step14"></a>
C++ Tutorial Step 14: Voicemails</h2>
<p>In this example we will write a program that </p>
<ul>
<li>If executed without voicemail target argument, will wait for and play incoming voice messages </li>
<li>If executed with valid target argument, will record and send a voice message to that target.</li>
</ul>
<p>Note that you will need at least one account with voice mailbox to run this demo.</p>
<p>In <a class="el" href="class_skype.html" title="The main class that exposes Skype-related functionality to your application. Currently the SDK only s...">Skype</a> <a class="el" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a> API, <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> is actually something of a misnomer for what would be more accurately called Voice <a class="el" href="class_message.html" title="Events in a conversation context are expressed as Messages. It is therefore useful to think of Messag...">Message</a>. Traditionally, the use case of Voicemails is when an incoming call does not get answered in a pre-determined amount of time, at which point the call will be recorded as a voicemail. In conversation API, the <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> class is separated from the call metaphor and instead, abstracting asynchronous voice (live) message in context of a <a class="el" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a>. <a class="el" href="class_skype.html" title="The main class that exposes Skype-related functionality to your application. Currently the SDK only s...">Skype</a> Voicemails can be posted in dialog conversations independently of the traditional mailbox logic. In fact, directing unanswered incoming live sessions to voicemail is not something that the <a class="el" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a> API will provide you with high-level action flow. Implementation of this use case is largely up to the client UI.</p>
<p>A good way to illustrate this conceptual difference between traditional voicemail and voice message is that to retrieve an incoming <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a>, you will need to monitor <a class="el" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a> class messages. There exists a special message type - <a class="el" href="class_message.html#a5305592a3170872320962a09d8a1c7feaf2b962360d864f9f9ef5bfa37cecb3f2">Message::POSTED_VOICE_MESSAGE</a> - indicating that the <a class="el" href="class_message.html" title="Events in a conversation context are expressed as Messages. It is therefore useful to think of Messag...">Message</a> object should be handled as a voice message instead of just displaying <a class="el" href="class_message.html" title="Events in a conversation context are expressed as Messages. It is therefore useful to think of Messag...">Message</a> body text in <a class="el" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a> UI. The Messages class has the <a class="el" href="class_message.html#a819bb0cb0fffa67514a283e3498550bd">Message::GetVoiceMessage</a> method that will retrieve the <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> object. Then <a class="el" href="class_voicemail.html#a2d482385cfecbf1f3b0994a5e03f8352">Voicemail::StartPlayback</a> method enables you to listen to the message audio.</p>
<p>To put it another way, the chain of objects goes like this: Contact-&gt;Conversation-&gt;Message-&gt;<a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a></p>
<p>There are three basic types of <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> objects: </p>
<ul>
<li>INCOMING - received voice messages that can be retrieved from <a class="el" href="class_message.html" title="Events in a conversation context are expressed as Messages. It is therefore useful to think of Messag...">Message</a> objects; </li>
<li>OUTGOING - outbound voice messages that can be created with <a class="el" href="class_conversation.html#a09c1660e520e5f569cb5d9bd00802d67">Conversation::StartVoiceMessage</a>; </li>
<li>Greeting - voice messages that represent auto-answer greetings, either recorded by the user (CUSTOM_GREETING) or included as part of SkypeKit (DEFAULT_GREETING). This is the audio that gets played back to sender of the voice message before he can start recording his voice message.</li>
</ul>
<p>Before trying to send out a voice message, you should check whether the target <a class="el" href="class_contact.html" title="Address book entry. Encapsulates methods like GetType, GetIdentity, GetAvatar, SendAuthRequest, OpenConversation etc. Single contact can have additional phone numbers attached to it (ASSIGNED_PHONE1 .. ASSIGNED_PHONE3). Note that in the context of a conversation, Contacts are represented by Participant objects.">Contact</a> has the capability to receive them. </p>
<div class="fragment"><pre class="fragment"><a class="code" href="class_contact.html#ab9d8d140522e785b3c2eeaa1c856eec6">Contact::CAPABILITYSTATUS</a> vmCapability;
contact-&gt;GetCapabilityStatus(<a name="a0"></a><a class="code" href="class_contact.html#a4729138ae1f273d2604c0896eeee9dcea4f83a3b719fe89ac742cdac3351ecf7c">Contact::CAPABILITY_CAN_BE_SENT_VM</a>, 
contact-&gt;vmCapability);
<span class="keywordflow">if</span> (vmCapability == <a name="a1"></a><a class="code" href="class_contact.html#ab9d8d140522e785b3c2eeaa1c856eec6ab7feb6ecd54789c97b7eab18f959686e">Contact::CAPABILITY_EXISTS</a>) {
    <span class="comment">// Can send voicemails</span>
};
</pre></div><h2><a class="anchor" id="RecAndSendVM"></a>
Recording and Sending a Voice Message</h2>
<p>The first step is to obtain a dialog <a class="el" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a> with the target <a class="el" href="class_contact.html" title="Address book entry. Encapsulates methods like GetType, GetIdentity, GetAvatar, SendAuthRequest, OpenConversation etc. Single contact can have additional phone numbers attached to it (ASSIGNED_PHONE1 .. ASSIGNED_PHONE3). Note that in the context of a conversation, Contacts are represented by Participant objects.">Contact</a>. In that conversation, you can initiate the outgoing voice message like this: </p>
<div class="fragment"><pre class="fragment">conv-&gt;StartVoiceMessage();
</pre></div><p>Note that this call does not return an actual <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> object. To catch when an object gets created, you will need to check <a class="el" href="class_conversation.html#a1fccc07009257810420d23e2174cad77aac0a73a8803ed665b644190d68535cd7">Conversation::P_ACTIVE_VM_ID</a> property updates.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyConversation::OnChange(<span class="keywordtype">int</span> prop)
{
    <span class="keywordflow">if</span> (prop == <a name="a2"></a><a class="code" href="class_conversation.html#a1fccc07009257810420d23e2174cad77aac0a73a8803ed665b644190d68535cd7">Conversation::P_ACTIVE_VM_ID</a>)
    {
        MyVoicemail::Ref newVM;
        this-&gt;GetPropActiveVmId(newVM);
    };
};
</pre></div><p>After invoking <a class="el" href="class_conversation.html#a09c1660e520e5f569cb5d9bd00802d67">Conversation::StartVoiceMessage</a>, SkypeKit creates a <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> object for the target Contact's greeting (with type CUSTOM_GREETING or DEFAULT_GREETING). At this point, the <a class="el" href="class_conversation.html#a1fccc07009257810420d23e2174cad77aac0a73a8803ed665b644190d68535cd7">Conversation::P_ACTIVE_VM_ID</a> property update fires, newVM contains a reference to the greeting, and playback of the greeting for the sender starts automatically.</p>
<p>Once the greeting playback finishes, SkypeKit creates a second <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> object to contain the outgoing voice message. At this point, the <a class="el" href="class_conversation.html#a1fccc07009257810420d23e2174cad77aac0a73a8803ed665b644190d68535cd7">Conversation::P_ACTIVE_VM_ID</a> property update fires again, newVM now contains a reference to the outgoing message, and recording starts automatically. If you want to include notification and/or error handling for whether this message was sent successfully, you should make a copy of newVM now.</p>
<p>Once the user finishes (or abandons) recording of their message, they want to either send the message or to cancel it. To send the message, you can: </p>
<div class="fragment"><pre class="fragment">conv-&gt;PostVoiceMessage(vm, <span class="stringliteral">&quot;Voicemail body text&quot;</span>);
</pre></div><p> ..and to cancel the message: </p>
<div class="fragment"><pre class="fragment">conv-&gt;LeaveLiveSession();
</pre></div><p>Both of these actions results in the <a class="el" href="class_conversation.html#a1fccc07009257810420d23e2174cad77aac0a73a8803ed665b644190d68535cd7">Conversation::P_ACTIVE_VM_ID</a> property update firing for a third time, setting the value to NULL. However, the <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> object will actually continue its existence past this point. Saving a reference to the message's <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> object when you start recording it enables you to keep receiving <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> property updates. This in turn enables your UI to check whether voice message send succeeded or failed.</p>
<p>The relevant final-state <a class="el" href="class_voicemail.html#af4594255991c4ac495ef9fb4d0f53c16abde8c948d68da1c6f855e734654471f1">Voicemail::P_STATUS</a> property values are: </p>
<ul>
<li><a class="el" href="class_voicemail.html#ac326e2f7ac382ce407fa37d4d91ab437a95bd717d54d23b9c5392e8799c29be59">Voicemail::CANCELLED</a> - recording and/or sending of this message was cancelled </li>
<li><a class="el" href="class_voicemail.html#ac326e2f7ac382ce407fa37d4d91ab437a073dae03d03a499e1416839d5962a024">Voicemail::UPLOADED</a> - message sent </li>
<li><a class="el" href="class_voicemail.html#ac326e2f7ac382ce407fa37d4d91ab437aa92ed55692b4e0c800d45b96b5a300e8">Voicemail::FAILED</a> - message could not be sent</li>
</ul>
<h2><a class="anchor" id="RecvAndPlaybackVM"></a>
Receiving and Playing Back a Voice Message</h2>
<p>On the remote side, the <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> appears as a <a class="el" href="class_message.html" title="Events in a conversation context are expressed as Messages. It is therefore useful to think of Messag...">Message</a> object of type <a class="el" href="class_message.html#a5305592a3170872320962a09d8a1c7feaf2b962360d864f9f9ef5bfa37cecb3f2">Message::POSTED_VOICE_MESSAGE</a>. The message's author property contains the SkypeName of the <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> originator, and its BodyXml property contains the message length and title text in following format: </p>
<div class="fragment"><pre class="fragment">&lt;voicemail alt=<span class="stringliteral">&quot;Sent voicemail to people in this conversation.&quot;</span>&gt;&lt;message length=<span class="stringliteral">&quot;5&quot;</span> &gt;&lt;/message&gt;&lt;/voicemail&gt;
</pre></div><p>Receiver side UI can then retrieve the <a class="el" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a> object from the message and start local playback, like this: </p>
<div class="fragment"><pre class="fragment">MyVoicemail::Ref newVM;
message-&gt;GetVoiceMessage(this-&gt;activeVM);
this-&gt;activeVM-&gt;StartPlayback();
</pre></div><h2><a class="anchor" id="Step14FullCode"></a>
Full code of this example</h2>
<div class="fragment"><pre class="fragment"><span class="comment">/****************************************************************************</span>
<span class="comment"></span>
<span class="comment">Getting Started With SkypeKit. Tutorial Application, Step 14.</span>
<span class="comment"></span>
<span class="comment">In this example we will write a program that:</span>
<span class="comment"></span>
<span class="comment"> 1. If executed without voicemail target argument, will wait for </span>
<span class="comment">    and play incoming voice messages</span>
<span class="comment"> 2. If executed with valid target argument, will record and send</span>
<span class="comment">    a voice message to that target.</span>
<span class="comment"></span>
<span class="comment">Note that you will need at least one account with voice mailbox to </span>
<span class="comment">run this demo.</span>
<span class="comment"></span>
<span class="comment">**/</span>

<span class="preprocessor">#include &quot;<a class="code" href="skype-embedded__2_8h.html">skype-embedded_2.h</a>&quot;</span>
<span class="preprocessor">#include &quot;keypair.h&quot;</span>
<span class="preprocessor">#include &quot;tutorial_common.h&quot;</span>

<span class="keyword">using namespace </span>Sid;

<a name="_a3"></a><a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> myAccountName;
<a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> myAccountPsw;
<a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> myVoicemailTarget;

<span class="comment">//----------------------------------------------------------------------------</span>
<span class="comment">// Interface section</span>

<span class="keyword">class </span>MyVoicemail : <span class="keyword">public</span> <a name="_a4"></a><a class="code" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a>
{
<span class="keyword">public</span>:
  <span class="keyword">typedef</span> DRef&lt;MyVoicemail, Voicemail&gt; Ref;
  <span class="keyword">typedef</span> DRefs&lt;MyVoicemail, Voicemail&gt; Refs;

  <span class="keywordtype">bool</span> vmRecordingStarted;
  <span class="keywordtype">bool</span> vmFinishedIncoming;
  <span class="keywordtype">bool</span> vmFinishedSending;

  MyVoicemail(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oid, SERootObject* root) : <a class="code" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a>(oid, root) 
  {
    vmFinishedIncoming = <span class="keyword">false</span>;
    vmFinishedSending  = <span class="keyword">false</span>;
    vmRecordingStarted = <span class="keyword">false</span>;
  };

  <span class="keywordtype">void</span> OnChange(<span class="keywordtype">int</span> prop);
};


<span class="keyword">class </span>MyConversation : <span class="keyword">public</span> <a name="_a5"></a><a class="code" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a>
{
<span class="keyword">public</span>:
  <span class="keyword">typedef</span> DRef&lt;MyConversation, Conversation&gt; Ref;
  <span class="keyword">typedef</span> DRefs&lt;MyConversation, Conversation&gt; Refs;

  MyVoicemail::Ref activeVM;

  MyConversation(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oid, SERootObject* root) : <a class="code" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a>(oid, root) 
  { 
    activeVM = NULL;
  };

  <span class="keywordtype">void</span> OnChange(<span class="keywordtype">int</span> prop);
  <span class="keywordtype">void</span> OnMessage (<span class="keyword">const</span> <a name="_a6"></a><a class="code" href="class_message_ref.html" title="Reference to an Message class instance, equivalent to Message::Ref.">MessageRef</a>&amp; message);
};


<span class="keyword">class </span>MySkype : <span class="keyword">public</span> <a name="_a7"></a><a class="code" href="class_skype.html" title="The main class that exposes Skype-related functionality to your application. Currently the SDK only s...">Skype</a>
{
<span class="keyword">public</span>:
  MySkype() : <a class="code" href="class_skype.html" title="The main class that exposes Skype-related functionality to your application. Currently the SDK only s...">Skype</a>() {}
  <a name="_a8"></a><a class="code" href="class_account.html" title="Represents a local account. Encapsulates methods for Skype account creation, login and logout as well...">Account</a>*    newAccount(<span class="keywordtype">int</span> oid)      { <span class="keywordflow">return</span> <span class="keyword">new</span> MyAccount(oid, <span class="keyword">this</span>);}
  <a class="code" href="class_conversation.html" title="The Conversation class encapsulates all types of communication possible with Skype client...">Conversation</a>*  newConversation(<span class="keywordtype">int</span> oid)  { <span class="keywordflow">return</span> <span class="keyword">new</span> MyConversation(oid, <span class="keyword">this</span>);}
  <a class="code" href="class_voicemail.html" title="Wrapper class that includes voicemail-specific methods and properties.">Voicemail</a>*    newVoicemail(<span class="keywordtype">int</span> oid)    { <span class="keywordflow">return</span> <span class="keyword">new</span> MyVoicemail(oid, <span class="keyword">this</span>);}

  MyConversation::Refs inbox;
  <span class="keywordtype">void</span> OnConversationListChange (
      <span class="keyword">const</span> <a name="_a9"></a><a class="code" href="class_conversation_ref.html" title="Reference to an Conversation class instance, equivalent to Conversation::Ref.">ConversationRef</a> &amp; conversation,
      <span class="keyword">const</span> <a class="code" href="class_conversation.html#a0eb196dd7006e1e37ba1c246c30d6183">Conversation::LIST_TYPE</a> &amp; type,
      <span class="keyword">const</span> <span class="keywordtype">bool</span> &amp; added);
};


<span class="comment">//----------------------------------------------------------------------------</span>
<span class="comment">// Implementation section</span>
<span class="comment"></span>
<span class="comment">/** In MyVoicemail::OnChange we will keep looking for two cases of P_STATUS property change:</span>
<span class="comment">1. status == PLAYED &amp;&amp; type == INCOMING - playback of incoming VM has finished.</span>
<span class="comment">2. status == UPLOADED || status == FAILED || status == Voicemail::CANCELLED - </span>
<span class="comment">   sending of an outgoing VM has finished with any of the three final states.</span>
<span class="comment">   In case of FAILED we will also print out the string version of the P_FAILUREREASON **/</span>

<span class="keywordtype">void</span> MyVoicemail::OnChange(<span class="keywordtype">int</span> prop)
{
  <span class="keywordflow">if</span> (prop == <a name="a10"></a><a class="code" href="class_voicemail.html#af4594255991c4ac495ef9fb4d0f53c16abde8c948d68da1c6f855e734654471f1">Voicemail::P_STATUS</a>)
  {
    <a class="code" href="class_voicemail.html#ac326e2f7ac382ce407fa37d4d91ab437">Voicemail::STATUS</a> status;
    this-&gt;GetPropStatus(status);

    <a class="code" href="class_voicemail.html#a436c29a3015c5b9e8271595d0f4fc721">Voicemail::TYPE</a> type;
    this-&gt;GetPropType(type);

    <span class="keywordflow">if</span> ((status == <a name="a11"></a><a class="code" href="class_voicemail.html#ac326e2f7ac382ce407fa37d4d91ab437aa45c53e2cfdd5df47a22bcbbe151e566">Voicemail::PLAYED</a>) &amp;&amp; (type == <a name="a12"></a><a class="code" href="class_voicemail.html#a436c29a3015c5b9e8271595d0f4fc721a5b26cba585f5aff0ae68c960e8c6737f">Voicemail::INCOMING</a>))
    {
      vmFinishedIncoming = <span class="keyword">true</span>;
      printf(<span class="stringliteral">&quot;VM playback is finished. Press ENTER to quit.\n&quot;</span>);
      <span class="keywordflow">return</span>;
    };

    <span class="keywordflow">if</span> ((status == <a name="a13"></a><a class="code" href="class_voicemail.html#ac326e2f7ac382ce407fa37d4d91ab437a073dae03d03a499e1416839d5962a024">Voicemail::UPLOADED</a>) || (status == <a name="a14"></a><a class="code" href="class_voicemail.html#ac326e2f7ac382ce407fa37d4d91ab437aa92ed55692b4e0c800d45b96b5a300e8">Voicemail::FAILED</a>) || (status == <a name="a15"></a><a class="code" href="class_voicemail.html#ac326e2f7ac382ce407fa37d4d91ab437a95bd717d54d23b9c5392e8799c29be59">Voicemail::CANCELLED</a>))
    {
      vmFinishedSending = <span class="keyword">true</span>;

      <span class="keywordflow">if</span> (status == <a class="code" href="class_voicemail.html#ac326e2f7ac382ce407fa37d4d91ab437aa92ed55692b4e0c800d45b96b5a300e8">Voicemail::FAILED</a>)
      {
        <a class="code" href="class_voicemail.html#a3128b62950cd7f30bd2c0dcac233d055">Voicemail::FAILUREREASON</a> failReason;
        this-&gt;GetPropFailurereason(failReason);
        printf(<span class="stringliteral">&quot;%s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)tostring(failReason));
      };
    };

    <span class="comment">// Voicemail::STATUS</span>
    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)tostring(status));
  }
  <span class="keywordflow">else</span>
  {
    <span class="comment">// In case of non-P_STATUS property updates, we just print out notifications</span>
    <a name="_a16"></a><a class="code" href="class_s_e_string_list.html" title="SEStringList represents a list of strings (SEString objects).">SEStringList</a> dbg;
    <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> propStr = this-&gt;GetProp(prop);
    dbg = this-&gt;getPropDebug(prop, propStr);
    printf(<span class="stringliteral">&quot;VM %s -&gt; %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)dbg[1], (<span class="keyword">const</span> <span class="keywordtype">char</span>*)propStr);  
  };
};
<span class="comment"></span>
<span class="comment">/** MyConversation::OnMessage is where we actually handle detection and playback of incoming </span>
<span class="comment">voicemails. For detection, we will check type of each incoming message for POSTED_VOICE_MESSAGE</span>
<span class="comment">For messages of that type, we can retrieve a Voicemail object with Message::GetVoiceMessage</span>
<span class="comment">and then start playback with Voicemail::StartPlayback.</span>
<span class="comment"></span>
<span class="comment">We can then detect when the playback is finished from the Voicemail::OnChange callback,</span>
<span class="comment">by checking if the type is INCOMING and rthe status is PLAYED. **/</span>

<span class="keywordtype">void</span> <a name="a17"></a><a class="code" href="class_conversation.html#a887a117127a957342ae11338decb589b">MyConversation::OnMessage</a> (<span class="keyword">const</span> <a class="code" href="class_message_ref.html" title="Reference to an Message class instance, equivalent to Message::Ref.">MessageRef</a>&amp; message)
{
  <a class="code" href="class_message.html#a5305592a3170872320962a09d8a1c7fe">Message::TYPE</a> msgType;
  message-&gt;GetPropType(msgType);

  <span class="keywordflow">if</span> (msgType == <a name="a18"></a><a class="code" href="class_message.html#a5305592a3170872320962a09d8a1c7feaf2b962360d864f9f9ef5bfa37cecb3f2">Message::POSTED_VOICE_MESSAGE</a>)
  {
    <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> msgAuthor;
    message-&gt;GetPropAuthor(msgAuthor);

    <span class="keywordflow">if</span> (msgAuthor == myAccountName)
    {
      <span class="comment">// This check is necessary for filtering out the VMs we have just</span>
      <span class="comment">// sent ou ourselves. Conversation::OnMessage fires for those as well.</span>
      <span class="keywordflow">return</span>;
    };

    <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> msgBody;
    message-&gt;GetPropBodyXml(msgBody);

    printf(<span class="stringliteral">&quot;We got incoming voicemail!\n&quot;</span>);
    printf(<span class="stringliteral">&quot;Author: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)msgAuthor);
    printf(<span class="stringliteral">&quot;Body: %s\n\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)msgBody);

    <span class="keywordflow">if</span> (activeVM)
    {
      printf(<span class="stringliteral">&quot;We already have an active voicemail object..\n&quot;</span>);
    }
    <span class="keywordflow">else</span>
    {
      printf(<span class="stringliteral">&quot;Starting playback.\n&quot;</span>);
      message-&gt;GetVoiceMessage(this-&gt;activeVM);
      this-&gt;activeVM-&gt;StartPlayback();
    };
  };
};
<span class="comment"></span>
<span class="comment">/** The MyConversation::OnChange is the only place we can get to know when </span>
<span class="comment">Voicemail objects are created by the runtime. For this we need to monitor </span>
<span class="comment">the Conversation::P_ACTIVE_VM_ID property changes. If this property is</span>
<span class="comment">updated - we can call GetPropActiveVmId to retrieve a reference to the</span>
<span class="comment">current active Voicemail object.</span>
<span class="comment"></span>
<span class="comment">For each outgoing VM, we will have three P_ACTIVE_VM_ID property changes:</span>
<span class="comment">1. the incoming &quot;greeting&quot; VM object that gets played back</span>
<span class="comment">2. the outgoing VM that will be recorded and sent</span>
<span class="comment">3. and finally, the P_ACTIVE_VM_ID property will reset to 0.</span>
<span class="comment"></span>
<span class="comment">NB! The last step - the reset - will happen -before- the VM reaches</span>
<span class="comment">it&#39;s final state (for example UPLOADDED). To catch the final Voicemail</span>
<span class="comment">status update (especially in case it turns out to be FAILED), </span>
<span class="comment">we will need to keep a reference to the active Voicemail object</span>
<span class="comment">even after Conversation resets the active vm id to 0.</span>
<span class="comment">    </span>
<span class="comment">This is also why we use local variable newVM in GetPropActiveVmId</span>
<span class="comment">call, instead of immediately reloading the MyConversation::activeVM</span>
<span class="comment">variable. **/</span>

<span class="keywordtype">void</span> MyConversation::OnChange(<span class="keywordtype">int</span> prop)
{  
  <span class="keywordflow">if</span> (prop == <a class="code" href="class_conversation.html#a1fccc07009257810420d23e2174cad77aac0a73a8803ed665b644190d68535cd7">Conversation::P_ACTIVE_VM_ID</a>)
  {
    MyVoicemail::Ref newVM;
    this-&gt;GetPropActiveVmId(newVM);

    <span class="keywordflow">if</span> (!newVM)
    {
      printf(<span class="stringliteral">&quot;Conversation cleared active voicemail ID\n&quot;</span>);
      <span class="keywordflow">return</span>;
    };

    activeVM = newVM;

    <a class="code" href="class_voicemail.html#a436c29a3015c5b9e8271595d0f4fc721">Voicemail::TYPE</a> vmType;
    activeVM-&gt;GetPropType(vmType);

    <span class="comment">// Printing out the Voicemail type (incoming, greeting, outgoing)</span>
    <a class="code" href="class_s_e_string_list.html" title="SEStringList represents a list of strings (SEString objects).">SEStringList</a> dbg;
    dbg = activeVM-&gt;getPropDebug(<a name="a19"></a><a class="code" href="class_voicemail.html#af4594255991c4ac495ef9fb4d0f53c16abb710cf843c32a2ca6c02818b7910c36">Voicemail::P_TYPE</a>, vmType);
    printf(<span class="stringliteral">&quot;Conversation has created a new %s voicemail!\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)dbg[2]);

    <span class="comment">// If an outgoing VM was created, recording will start automatically.</span>
    <span class="keywordflow">if</span> (vmType == <a name="a20"></a><a class="code" href="class_voicemail.html#a436c29a3015c5b9e8271595d0f4fc721aa4cc86d58670c67573846fd14c8931f3">Voicemail::OUTGOING</a>)
    {
      activeVM-&gt;vmRecordingStarted = <span class="keyword">true</span>;
    };
    <span class="keywordflow">return</span>;
  };
  <span class="comment"></span>
<span class="comment">  /** Voicemails also trigger other Conversation property changes,</span>
<span class="comment">  such as LIVE_START_TIMESTAMP, LOCAL_LIVESTATUS, etc.</span>
<span class="comment">  For context, we will printf out all Conversation prop changes</span>
<span class="comment">  as well. Handling LOCAL_LIVESTATUS separately here, so that </span>
<span class="comment">  the livestatus value gets printed as string rather than numeric. **/</span>
  <span class="keywordflow">if</span> (prop == <a name="a21"></a><a class="code" href="class_conversation.html#a1fccc07009257810420d23e2174cad77a874a491d61fbfbfca75a722a4127502e">Conversation::P_LOCAL_LIVESTATUS</a>)
  {
    <a class="code" href="class_conversation.html#a65f54d9d78c06e3164b73cbba8df0f8f">Conversation::LOCAL_LIVESTATUS</a> liveStatus;
    this-&gt;GetPropLocalLivestatus(liveStatus);
    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)tostring(liveStatus));

    <span class="keywordflow">return</span>;
  };

  <a class="code" href="class_s_e_string_list.html" title="SEStringList represents a list of strings (SEString objects).">SEStringList</a> dbg;
  <a class="code" href="class_s_e_string.html" title="SEString is basic char* based string class.">SEString</a> propStr = this-&gt;GetProp(prop);
  dbg = this-&gt;getPropDebug(prop, propStr);
  printf(<span class="stringliteral">&quot;Conv::%s -&gt; %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)dbg[1], (<span class="keyword">const</span> <span class="keywordtype">char</span>*)propStr);  
};
<span class="comment"></span>
<span class="comment">/** MySkype::OnConversationListChange needs to be monitored for changes </span>
<span class="comment">in INBOX_CONVERSATIONS conversation list, so that we allways have an</span>
<span class="comment">up-to-date skype-&gt;inbox variable to catch all Conersation::OnMessage</span>
<span class="comment">events for incoming voicemails. **/</span>

<span class="keywordtype">void</span> <a name="a22"></a><a class="code" href="class_skype.html#a6e47d0fc195995491b449336010bd520">MySkype::OnConversationListChange</a> (
    <span class="keyword">const</span> <a class="code" href="class_conversation_ref.html" title="Reference to an Conversation class instance, equivalent to Conversation::Ref.">ConversationRef</a> &amp; conversation,
    <span class="keyword">const</span> <a class="code" href="class_conversation.html#a0eb196dd7006e1e37ba1c246c30d6183">Conversation::LIST_TYPE</a> &amp; type,
    <span class="keyword">const</span> <span class="keywordtype">bool</span> &amp; added)
{
  <span class="keywordflow">if</span> (type == <a name="a23"></a><a class="code" href="class_conversation.html#a0eb196dd7006e1e37ba1c246c30d6183ae7c8d74ae98eacac61f4897b21096a68">Conversation::INBOX_CONVERSATIONS</a>)
  {
    this-&gt;GetConversationList(inbox, <a class="code" href="class_conversation.html#a0eb196dd7006e1e37ba1c246c30d6183ae7c8d74ae98eacac61f4897b21096a68">Conversation::INBOX_CONVERSATIONS</a>);
    fetch(inbox);
  };
};

<span class="comment">//----------------------------------------------------------------------------</span>
<span class="comment">// Main</span>

MySkype* skype = 0;

<span class="keywordtype">void</span> SendVoicemail()

{
  MyVoicemail::Ref  vm;
  MyConversation::Ref conv;

  <a name="_a24"></a><a class="code" href="class_contact_ref.html" title="Reference to an Contact class instance, equivalent to Contact::Ref.">ContactRef</a> contact;
  skype-&gt;GetContact(myVoicemailTarget, contact);

  <a class="code" href="class_contact.html#ab9d8d140522e785b3c2eeaa1c856eec6">Contact::CAPABILITYSTATUS</a> vmCapability;
  contact-&gt;GetCapabilityStatus(<a class="code" href="class_contact.html#a4729138ae1f273d2604c0896eeee9dcea4f83a3b719fe89ac742cdac3351ecf7c">Contact::CAPABILITY_CAN_BE_SENT_VM</a>, vmCapability);

  <span class="keywordflow">if</span> (vmCapability != <a class="code" href="class_contact.html#ab9d8d140522e785b3c2eeaa1c856eec6ab7feb6ecd54789c97b7eab18f959686e">Contact::CAPABILITY_EXISTS</a>)
  {
    printf(<span class="stringliteral">&quot;ERROR: Cannot send voicemail to %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)myVoicemailTarget);
  }
  <span class="keywordflow">else</span>
  {
    printf(<span class="stringliteral">&quot;Can send voicemail to %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)myVoicemailTarget);

    skype-&gt;GetConversationByIdentity(myVoicemailTarget, conv);

    printf(<span class="stringliteral">&quot;Press ENTER to start sending the voicemail.\n&quot;</span>);
    getchar();

    conv-&gt;StartVoiceMessage();

    <span class="comment">// Loop until VM object is created. This object is the &quot;greeting&quot; voicemail</span>
    <span class="comment">// that will automatically play back the &quot;leave message after beep&quot; audio.</span>
    <span class="comment">// Voicemail::P_TYPE is either DEFAULT_GREETING or CUSTOM_GREETING</span>
    <span class="keywordflow">while</span> (!conv-&gt;activeVM) { Delay(1); };
    printf(<span class="stringliteral">&quot;Stay tuned while playing &#39;leave message after the beep&#39; message..\n&quot;</span>);

    <span class="comment">// Loop until the 2nd VM object is created, with TYPE == OUTGOING</span>
    <span class="comment">// The 2nd VM is created automatically once the greeting playback is done.</span>
    <span class="keywordflow">while</span> (!conv-&gt;activeVM-&gt;vmRecordingStarted) { Delay(1); };

    <span class="comment">// The 2nd VM will now record local audio until ENTER is pressed.</span>
    printf(<span class="stringliteral">&quot;We are now recording a voice message.\n&quot;</span>);
    printf(<span class="stringliteral">&quot;Press ENTER to stop recording and send the voicemail.\n&quot;</span>);
    getchar();

    <span class="comment">// Posting the voicemail to the conversation.</span>
    conv-&gt;PostVoiceMessage(vm, <span class="stringliteral">&quot;Voicemail body text&quot;</span>);

    <span class="comment">// If at this point you decide to cancel the voicemail, you should use</span>
    <span class="comment">// Conversation::LeaveLiveSession() method, like this:</span>
    <span class="comment">// printf(&quot;Cancelling VM!\n&quot;);</span>
    <span class="comment">// conv-&gt;LeaveLiveSession();</span>
<span class="comment"></span>
<span class="comment">    /** The string argument will show up on remote side in the BODY_XML property</span>
<span class="comment">    of the corresponding Message object, like this:</span>
<span class="comment">    Message body: &lt;voicemail alt=&quot;Voicemail body text&quot;&gt;&lt;message length=&quot;7&quot;&gt;&lt;/message&gt;&lt;/voicemail&gt;</span>
<span class="comment">    Your UI should use this to display the voicemail in a conversation. **/</span>

    <span class="keywordflow">while</span> (!conv-&gt;activeVM-&gt;vmFinishedSending) {Delay(1);};
  };

  printf(<span class="stringliteral">&quot;Press ENTER to quit.\n&quot;</span>);
  getchar();
};

<span class="comment"></span>
<span class="comment">/** The WaitForVoicemail does not actually do much anything. The catching and </span>
<span class="comment">playback of incoming Voicemails is all done in the MyConversation::OnMessage</span>
<span class="comment">callback - where incoming messages with type == POSTED_VOICE_MESSAGE will </span>
<span class="comment">indicate that a new voicemail has arrived.</span>
<span class="comment"></span>
<span class="comment">The only trick here is that to get those MyConversation::OnMessage events,</span>
<span class="comment">you need to have live references to all relevant conversations in your</span>
<span class="comment">wrapper object cache. For this we will need to have a ConversationRefs list</span>
<span class="comment">that never goes out of scope (in this case inbox variable in MySkype class).</span>
<span class="comment"></span>
<span class="comment">By retrieving INBOX_CONVERSATIONS conversations into that variable, we will</span>
<span class="comment">make sure that we will get all the MyConversation::OnMessage events in our </span>
<span class="comment">active chats. Well, almost.  There is also the case of new or dormant </span>
<span class="comment">conversations being added to the inbox. To handle that, we can override  </span>
<span class="comment">MySkype::OnConversationListChange and re-load the inbox again. **/</span>

<span class="keywordtype">void</span> WaitForVoicemail()
{
  skype-&gt;GetConversationList(skype-&gt;inbox, <a class="code" href="class_conversation.html#a0eb196dd7006e1e37ba1c246c30d6183ae7c8d74ae98eacac61f4897b21096a68">Conversation::INBOX_CONVERSATIONS</a>);
  fetch(skype-&gt;inbox);

  printf(<span class="stringliteral">&quot;Waiting for incoming voicemails..\n&quot;</span>);
  printf(<span class="stringliteral">&quot;Press ENTER to quit.\n&quot;</span>);
  getchar();
};

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
  printf(<span class="stringliteral">&quot;*****************************************************************\n&quot;</span>);
  printf(<span class="stringliteral">&quot; SkypeKit Tutorial, Step 14. - Voice messages (Voicemails)\n&quot;</span>);
  printf(<span class="stringliteral">&quot;*****************************************************************\n&quot;</span>);

  <span class="keywordflow">if</span> (argc &lt; 3)
  {
      printf(<span class="stringliteral">&quot;usage: tutorial_14 &lt;skypename&gt; &lt;password&gt; [target]\n&quot;</span>);
      <span class="keywordflow">return</span> 0;
  };

  myAccountName = argv[1];
  myAccountPsw  = argv[2];

  <span class="keywordflow">if</span> (argv[3])
  {
    myVoicemailTarget  = argv[3];
  };

  printf(<span class="stringliteral">&quot;Creating skype ..\n&quot;</span>);
  skype = <span class="keyword">new</span> MySkype();

  printf(<span class="stringliteral">&quot;Submitting application token..\n&quot;</span>);
  getKeyPair ();
  skype-&gt;init(keyBuf, inetAddr, portNum, <span class="stringliteral">&quot;streamlog.txt&quot;</span>);
  skype-&gt;start();

  printf(<span class="stringliteral">&quot;Retrieving account ..\n&quot;</span>);
  MyAccount::Ref account;

  <span class="keywordflow">if</span> (skype-&gt;GetAccount(myAccountName, account))
  {
    printf(<span class="stringliteral">&quot;Logging in..\n&quot;</span>);
    account-&gt;LoginWithPassword(myAccountPsw, <span class="keyword">false</span>, <span class="keyword">true</span>);
    account-&gt;BlockWhileLoggingIn();
    printf(<span class="stringliteral">&quot;Loggin complete.\n&quot;</span>);
    
    <span class="keywordflow">if</span> (argv[3])
    {
      <span class="comment">// If we have a target argument - we will send a VM..</span>
      SendVoicemail();
    }
    <span class="keywordflow">else</span>
    {
      <span class="comment">// ..if we don&#39;t, we will wait for incoming VMs</span>
      WaitForVoicemail();
    };

    printf(<span class="stringliteral">&quot;Logging out..\n&quot;</span>);
    account-&gt;Logout(<span class="keyword">false</span>);

    account-&gt;BlockWhileLoggingOut();
    printf(<span class="stringliteral">&quot;Logout complete.\n&quot;</span>);
  }
  <span class="keywordflow">else</span>
  {
      printf(<span class="stringliteral">&quot;Account does not exist\n&quot;</span>);
  };

  printf(<span class="stringliteral">&quot;Cleaning up.\n&quot;</span>);
  skype-&gt;stop();
  <span class="keyword">delete</span> skype;
  printf(<span class="stringliteral">&quot;Done.\n&quot;</span>);
  <span class="keywordflow">return</span> 0;
};
</pre></div> </div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<hr/>	
		<p><b>(c) Skype Technologies S.A. Confidential/Proprietary</b></p>		
		<p>Last updated: Fri Oct 7 2011</p>		
		</BODY>
</HTML>
